# -*- coding: utf-8 -*-
"""Titanic_NN_Updated.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d3fS5ebiGw0jebVnOeJlXEsK7Zi_rljJ
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.neural_network import MLPClassifier
from sklearn.preprocessing import StandardScaler
from sklearn import metrics
from sklearn.pipeline import Pipeline

np.random.seed(1)
# Load and preprocess data
df = pd.read_csv('Titanic.csv')
df = pd.get_dummies(df, columns=['Pclass', 'Sex'], drop_first=True)
y = df.Survived
X = df[['Age', 'SibSp', 'Parch', 'Fare', 'Pclass_2', 'Pclass_3', 'Sex_male']]
x_train, x_test, y_train, y_test = train_test_split(X, y, random_state=10)

# Build pipeline
pipeline = Pipeline([
    ('scaler', StandardScaler()),
    ('mlp', MLPClassifier(max_iter=800, random_state=10))
])

# Define parameters for grid search
parameters = {
    'mlp__hidden_layer_sizes': [(50,50), (100, 50), (100,),(100,100)],
    'mlp__activation': ['relu', 'tanh', 'logistic'],
    'mlp__learning_rate': ['constant', 'adaptive', 'invscaling'],
    'mlp__alpha': [0.00001, 0.0001, 0.001],
    'mlp__solver': ['adam']
}

# Perform grid search
cv = GridSearchCV(pipeline, parameters, cv=10)
cv.fit(x_train, y_train)

# Print best parameters and results
print('Best parameters: {}\n'.format(cv.best_params_))
mean = cv.cv_results_['mean_test_score']
std = cv.cv_results_['std_test_score']
for mean_score, std_score, params in zip(mean, std, cv.cv_results_['params']):
    print('{} (+/-{}) for {}'.format(mean_score, std_score * 2, params))

# Use the best estimator to make predictions
best_model = cv.best_estimator_
predictions = best_model.predict(x_test)

# Print evaluation metrics
print('Accuracy:', metrics.accuracy_score(y_test, predictions))
print('Confusion Matrix:\n', metrics.confusion_matrix(y_test, predictions))
print('Classification Report:\n', metrics.classification_report(y_test, predictions))

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.neural_network import MLPClassifier
from sklearn.preprocessing import StandardScaler
from sklearn import metrics
from sklearn.pipeline import Pipeline

np.random.seed(1)

# Load and preprocess data
df = pd.read_csv('Titanic.csv')

# Feature engineering
df['Title'] = df['Name'].apply(lambda x: x.split(',')[1].split('.')[0].strip())
df['FamilySize'] = df['SibSp'] + df['Parch'] + 1
df['IsAlone'] = (df['FamilySize'] == 1).astype(int)
df = pd.get_dummies(df, columns=['Pclass', 'Sex', 'Embarked', 'Title'], drop_first=True)

# Select features
y = df.Survived
X = df[['Age', 'SibSp', 'Parch', 'Fare', 'FamilySize', 'IsAlone', 'Pclass_2', 'Pclass_3', 'Sex_male', 'Embarked_Q', 'Embarked_S', 'Title_Miss', 'Title_Mr', 'Title_Mrs']]


# Build pipeline
pipeline = Pipeline([
    ('scaler', StandardScaler()),
    ('mlp', MLPClassifier(max_iter=1000, random_state=10, early_stopping=True, n_iter_no_change=50))
])

# Define parameters for grid search
parameters = {
    'mlp__hidden_layer_sizes': [(50,50), (100, 50), (100,)],
    'mlp__activation': ['relu', 'tanh', 'logistic'],
    'mlp__learning_rate': ['constant', 'adaptive', 'invscaling'],
    'mlp__alpha': [0.0001, 0.001, 0.01, 0.1],
    'mlp__solver': ['adam']
}

# Perform grid search
cv = GridSearchCV(pipeline, parameters, cv=5)
cv.fit(x_train, y_train)

# Print best parameters and results
print('Best parameters: {}\n'.format(cv.best_params_))
mean = cv.cv_results_['mean_test_score']
std = cv.cv_results_['std_test_score']
for mean_score, std_score, params in zip(mean, std, cv.cv_results_['params']):
    print('{} (+/-{}) for {}'.format(mean_score, std_score * 2, params))

# Use the best estimator to make predictions
best_model = cv.best_estimator_
predictions = best_model.predict(x_test)

# Print evaluation metrics
print('Accuracy:', metrics.accuracy_score(y_test, predictions))
print('Confusion Matrix:\n', metrics.confusion_matrix(y_test, predictions))
print('Classification Report:\n', metrics.classification_report(y_test, predictions))

